<!DOCTYPE html>    <!-- this is a HTML comment -->    <!--  -->
<html lang="">    <!-- HTML page begs/ends w 'html' tag -->
  <head>    <!-- HTML page has 'head'section and 'body' section -->
    <meta foo="Time-stamp: <2020-09-20 22:42:25 Chuck Siska>">
    <!-- ================================================ Mods ====
     o- 2020-02-09 22:18:17: add btn onclick exported fn
     o- 2020-02-10 17:22:23: log btn onclick
     o- 2020-09-20 22:41:05; Add maze & supt drawing fns
    .-->
    <!--
        Some code, mod'd, from "Introducing JavaScript Game Development" by Stuart.
      -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jathp-P5-JS-HTML</title>     <!-- Browser or tab title -->
    <link rel="stylesheet" href="assets/styles.css">    <!-- Tiny CSS style file -->
    <style> body {padding: 0; margin: 0;} </style>    <!-- Bit of in-line CSS -->
    <script src="p5.js"></script>    <!-- Load P5.JS, one file -->
    <!-- For more P5.JS, CF https://github.com/processing/p5.js/wiki -->
    <script src="cs-sketch-paint.js"></script>    <!-- Load my setup+draw P5-req'd fcns -->

    <script type="text/javascript" src="Jathp.js"></script>    <!-- Load Jathp -->

  </head>
  <body>	 <!-- HTML page body-->
	<h1>CPSC 481 Project 1 -- A Star Search</h1> <!--header title-->
	<p>	
	Team Ook Ook.
	<p>    <!-- Step Counter -->
    	Bot's Tiles Count's:
	<p id="bot_tiles_count">    <!-- bot's tiles count's -->
  </body>    <!-- HTML display page ends here -->

<script src="assets/draw-stuff.js"></script> <!-- Load some JS fcns in a file -->

<!-- ==================================================================== -->

<script type="text/lisp"> ;File: prelude.lsp
; This file contains aliases and common definitions.
; It also imports the javascript Math functions.

(def + plus)
(def define def)
(def #t 't)
(def #f Nil)
(def nil Nil)
(def - minus)
(def / divide)
(def % rem)
(def * times)
(def = equal)
(def eq? equal)
(def head car)
(def first car)
(def tail cdr)
(def rest cdr)
(def eq equal)
(defun null (x) (equal x Nil))
(defun zerop (x) (equal x 0))
(defun plusp (x) (> x 0))
(defun minusp (x) (< x 0))
(defun evenp (x) (equal (rem x 2) 0))
(defun oddp (x) (/= (rem x 2) 1))

;; CS: pprint the Javathcript prelude fragment.
(defun member (E L) ;; CS: orig name was "list-member", non-std.
  (cond
   ((null L) Nil) ;; Not found in list L.
   ((equal E (first L)) L) ;; Found E, return L's remainder CS:Orig retval = 't.
   ('t (member E (rest L)))))  ;; Not in head, check tail.

(defun map (F L) ;;convert L=(e1 e2 ... eN) to ((F e1) (F e2) ... (F eN))
  (if (null L)
      Nil
    (cons (F (head L))
          (map F (tail L)))))


; CADDRs

(defun caar (x) (car (car x)))                    
(defun cadr (x) (car (cdr x)))                    
(defun cdar (x) (cdr (car x)))                   
(defun cddr (x) (cdr (cdr x)))                    
(defun caaar (x) (car (car (car x))))              
(defun caadr (x) (car (car (cdr x))))             
(defun cadar (x) (car (cdr (car x))))              
(defun caddr (x) (car (cdr (cdr x))))              
(defun cdaar (x) (cdr (car (car x))))              
(defun cdadr (x) (cdr (car (cdr x))))              
(defun cddar (x) (cdr (cdr (car x))))              
(defun cdddr (x) (cdr (cdr (cdr x))))              
(defun caaaar (x) (car (car (car (car x)))))        
(defun caaadr (x) (car (car (car (cdr x)))))        
(defun caadar (x) (car (car (cdr (car x)))))        
(defun caaddr (x) (car (car (cdr (cdr x)))))        
(defun cadaar (x) (car (cdr (car (car x)))))        
(defun cadadr (x) (car (cdr (car (cdr x)))))        
(defun caddar (x) (car (cdr (cdr (car x)))))        
(defun cadddr (x) (car (cdr (cdr (cdr x)))))        
(defun cdaaar (x) (cdr (car (car (car x)))))        
(defun cdaadr (x) (cdr (car (car (cdr x)))))        
(defun cdadar (x) (cdr (car (cdr (car x)))))        
(defun cdaddr (x) (cdr (car (cdr (cdr x)))))        
(defun cddaar (x) (cdr (cdr (car (car x)))))        
(defun cddadr (x) (cdr (cdr (car (cdr x)))))        
(defun cdddar (x) (cdr (cdr (cdr (car x)))))        
(defun cddddr (x) (cdr (cdr (cdr (cdr x)))))        

; Some stuff specific to being run in a browser.

(def document (js "document"))
(def body (js "document.body"))
(def window (js "window"))
(def getElement (method document "getElementById"))
(def alert (method window "alert"))
(def message alert)
(def confirm (method window "confirm"))
(def console (js "console"))

; To be more like emacs, you might want to uncomment these two lines
; (def setp set)
; (def set def)

; Import PI and the javascript math functions.
;; CS: pprint the Javathcript prelude fragment.

(let* ((math (js "Math"))
       (import-math
        (lambda (funcname) 
          (def-dyn funcname (method math funcname)))))
  (map import-math
       '(sin cos tan asin acos atan atan2
         abs floor ceil round trunc
         max min
         pow exp sqrt log log2 log10
         hypot
         random)))

;; Jathp extras via defines; put here to be in correct scope.
(def expt pow)
(def != /=)

(defun append (x y)
  (cond ((null x) y)
        ('t (cons (car x) (append (cdr x) y)))))

</script>


<!-- ==================================================================== -->
<script type="text/lisp">
(defun msg (rlist) ;; Create webpage popup alert/msg.
  (list
    (message (concat "msg: " rlist ))))
</script>


<!-- ==================================================== stgr ==== -->
<script type="text/lisp">
;; CS: print fcn for Jathp (to console)
;; Must create a print-string for the value.
;; [CS: Crash sensitivity to dbl-quoted open, "("; needs leading space.]
(defun stgr (rx)
  (cond
   ((numberp rx) (concat "" rx))
   ((null rx) "nil")
   ((stringp rx) rx)
   ((atom rx) (concat "" rx))
   ((functionp rx) (fcn-guts rx))
;   ((functionp rx) "[function]")
   ((consp rx)
    (let* ((open (substring " (" 1 2)) ;; use space before '(': Crash sensitive.
           (rxlen (length rx))
           (retv (concat open (stgr (car rx))))) ;; Recur on lkid/car.
      (setq rx (cdr rx))
      (while rx
        (setq retv (concat retv " " (stgr (car rx)))) ;; Recur on lkid/car.
        (setq rx (cdr rx)))
      (concat retv ")")))
   (t "[Unknown object]")))

</script>

<!-- =========================================== btn onclick =========== -->

<!-- =========================================== End of page =========== -->

<!-- ====================================================  ==== -->
<script type="text/lisp">
</script>

<!-- ========================================================= logr ==== -->
<script type="text/lisp">

(defun logr (rx) ;; Shorter way to 'console.log in JS'.
  (let ((log (method console "log")))
    (log (concat "lp: "(stgr rx))))) ;; Nicer to strigify the lisp expr first.
;; tests
(logr "hello logr") ;; Announces that itself is available.
(logr logr) ;; Show example of what a Lisp fcn (AKA Lambda) looks like.
</script>

<!-- ====================================================== reverse ==== -->
<script type="text/lisp">
  (logr "Beg reverse =====")
(defun reverse (rlist)
  ;;"Return a list with the given elements in reverse order, or nil."
  (if (consp rlist) ;; Else nil.
      (let ((retv nil))
        (while rlist
          (setq retv (cons (car rlist) retv))
          (setq rlist (cdr rlist)))
        retv)))
  (logr "End reverse =====")
</script>

<!-- ========================================= lisp draw fn =========== -->
<script type="text/lisp">
;; Now Create simple draw fn & have P5 draw call it.
(logr "Beg html lisp draw fn ==========")
;; Use "jp-" prefix to avoid stepping on P5 fcns; namespace for the poor.
;; ================================================== jp-rect ====
(defun jp-rect (rx ry rwid rhgt) ;; x,y = upper-left corner pos, P5.
  (js (concat "rect(" rx "," ry "," rwid "," rhgt ")" )))

;; ================================================== jp-circle ====
(defun jp-circle (rx ry rdia) ;; x,y = center pos, P5.
  (js (concat "circle(" rx "," ry "," rdia ")" )))

;; ================================================== jp-cell-rbg-sum ====
(defun jp-pix-rbg-sum ( rx ry ) ;; rcx,rcy is upper-left cell corner pos.
(let* ((za (logr (list "pix-rbg-sum: rx,ry = " rx ry)))
         (px (+ 2 rx)) ;; Offset into cell.
         (py (+ 2 ry))
         (rbg-sum (js (concat "csjs_get_pixel_color_sum(" px "," py ")"))))
    (logr (list "rx,ry,px,py,rbg-sum = " rx ry px py rbg-sum)) 
    rbg-sum))

;; ================================================== jp-draw-bot ====
(def red-tiles '())

(defun set-black (rloc)
  (let* ((known (member rloc red-tiles)))
     (logr (list "known = " known))
     (if known
       (let ((pre-list (cdr (member rloc (reverse red-tiles)))))
         (def red-tiles
           (append (reverse pre-list) (cdr known)))))))

(defun set-red (rloc)
  (let* ((known (member rloc red-tiles)))
     (logr (list "known = " known))
     (if (not known)
      (def red-tiles (cons rloc red-tiles)))))

(defun jp-draw-bot ( )
  (let* ((aaa (logr "Enter jp-draw-bot"))
         (sz (js "g_grid.cell_size"))
         (zin (- sz 2))
         (botx (js "g_bot.x"))
         (boty (js "g_bot.y"))
         (xx (+ 1 (* sz botx)))
         (yy (+ 1 (* sz boty)))
         (pix (jp-pix-rbg-sum xx yy))
         (sctrl (js "g_sctrl")))
    ;(logr (stgr (list "draw sctrl,pix x,y =" sctrl pix xx yy )))
    (if (= 0 sctrl)
        (let ( )
          (js "stroke( 'gray' )" )
          (js "fill(204, 102, 0)" ) ;;red
          ;(logr "draw g_sctrl === 0" )
          (jp-rect xx yy zin zin)
          ;; Save red tile cell loc.
          (set-red (list botx boty))
          )
      (let ( )
        (js "stroke( 'gray' )" )
        (js "fill( 'black' )")
        ;(logr "draw g_sctrl !=== 1" )
        ;;(jp-circle xx yy zin)
        (set-black (list botx boty))
        (jp-rect xx yy zin zin)) )
    (logr (list "red-tiles =" red-tiles))))

;; ================================================== jp-move-bot ====
;; <!--============== search for the end spot ======== -->
(def coordinates(list '(0 2) '(0 3) '(0 4) '(0 9) '(0 10) '(0 11) '(0 12) '(0 13) '(1 0) '(1 1) '(1 2) '(1 4) '(1 5) '(1 6) '(1 7) '(1 8) '(1 9) '(1 12) '(1 13) '(1 14) '(1 15) '(1 16) '(1 20) '(1 21) '(1 22) '(1 23) '(1 24) '(2 0) '(2 2) '(2 4) '(2 6) '(2 12) '(2 16) '(2 17) '(2 18) '(2 19) '(2 20) '(2 22) '(2 24) '(2 25) '(2 26) '(3 0) '(3 1) '(3 2) '(3 4) '(3 5) '(3 6) '(3 8) '(3 9) '(3 10) '(3 11) '(3 12) '(3 20) '(3 21) '(3 22) '(3 26) '(3 27) '(4 1) '(4 8) '(4 10) '(4 14) '(4 15) '(4 16) '(4 17) '(4 21) '(4 27) '(5 1) '(5 2) '(5 3) '(5 4) '(5 8) '(5 9) '(5 10) '(5 12) '(5 13) '(5 14) '(5 17) '(5 18) '(5 19) '(5 20) '(5 21) '(5 24) '(5 25) '(5 26) '(5 27) '(6 4) '(6 5) '(6 6) '(6 9) '(6 12) '(6 14) '(6 19) '(6 24) '(6 26) '(7 6) '(7 7) '(7 8) '(7 9) '(7 12) '(7 13) '(7 14) '(7 16) '(7 17) '(7 18) '(7 19) '(7 24) '(7 25) '(7 26) '(8 2) '(8 3) '(8 4) '(8 8) '(8 12) '(8 16) '(8 20) '(8 21) '(8 22) '(8 25) '(9 0) '(9 1) '(9 2) '(9 4) '(9 5) '(9 6) '(9 8) '(9 9) '(9 10) '(9 12) '(9 15) '(9 16) '(9 17) '(9 20) '(9 22) '(9 23) '(9 24) '(9 25) '(10 0) '(10 2) '(10 4) '(10 6) '(10 8) '(10 10) '(10 12) '(10 15) '(10 17) '(10 18) '(10 19) '(10 20) '(10 24) '(10 25) '(10 26) '(11 0) '(11 1) '(11 2) '(11 4) '(11 5) '(11 6) '(11 8) '(11 9) '(11 10) '(11 11) '(11 12) '(11 15) '(11 16) '(11 17) '(11 20) '(11 21) '(11 24) '(11 26) '(12 0) '(12 5) '(12 8) '(12 10) '(12 21) '(12 24) '(12 25) '(12 26) '(13 0) '(13 4) '(13 5) '(13 6) '(13 7) '(13 8) '(13 10) '(13 12) '(13 13) '(13 14) '(13 20) '(13 21) '(13 22) '(14 0) '(14 4) '(14 10) '(14 11) '(14 12) '(14 14) '(14 15) '(14 16) '(14 20) '(14 22) '(14 23) '(14 24) '(14 25) '(14 26) '(15 0) '(15 4) '(15 5) '(15 10) '(15 12) '(15 13) '(15 14) '(15 16) '(15 18) '(15 19) '(15 20) '(15 21) '(15 22) '(15 26) '(16 0) '(16 5) '(16 8) '(16 9) '(16 10) '(16 16) '(16 18) '(16 26) '(17 0) '(17 4) '(17 5) '(17 6) '(17 8) '(17 10) '(17 12) '(17 13) '(17 14) '(17 16) '(17 18) '(17 19) '(17 20) '(17 21) '(17 24) '(17 25) '(17 26) '(18 0) '(18 1) '(18 4) '(18 6) '(18 8) '(18 9) '(18 10) '(18 12) '(18 14) '(18 15) '(18 16) '(18 21) '(18 24) '(18 26) '(19 1) '(19 4) '(19 5) '(19 6) '(19 8) '(19 12) '(19 13) '(19 14) '(19 19) '(19 20) '(19 21) '(19 24) '(19 25) '(19 26) '(20 1) '(20 6) '(20 8) '(20 9) '(20 10) '(20 13) '(20 19) '(20 21) '(20 22) '(20 23) '(20 25) '(21 1) '(21 5) '(21 6) '(21 8) '(21 10) '(21 11) '(21 12) '(21 13) '(21 19) '(21 21) '(21 23) '(21 25) '(22 1) '(22 2) '(22 4) '(22 5) '(22 8) '(22 9) '(22 10) '(22 16) '(22 17) '(22 18) '(22 19) '(22 21) '(22 22) '(22 23) '(22 25) '(22 26) '(23 2) '(23 4) '(23 16) '(23 26) '(24 2) '(24 4) '(24 16) '(24 22) '(24 23) '(24 24) '(24 26) '(25 0) '(25 1) '(25 2) '(25 4) '(25 12) '(25 13) '(25 14) '(25 15) '(25 16) '(25 17) '(25 18) '(25 19) '(25 20) '(25 21) '(25 22) '(25 24) '(25 25) '(25 26) '(26 0) '(26 2) '(26 4) '(26 5) '(26 6) '(26 7) '(26 12) '(26 16) '(26 18) '(27 0) '(27 1) '(27 2) '(27 7) '(27 10) '(27 11) '(27 12) '(27 16) '(27 17) '(27 18) '(27 19) '(27 20) '(27 21) '(27 22) '(27 23) '(27 24) '(28 0) '(28 7) '(28 10) '(28 24) '(29 0) '(29 4) '(29 5) '(29 6) '(29 7) '(29 10) '(29 12) '(29 13) '(29 14) '(29 20) '(29 21) '(29 22) '(29 23) '(29 24) '(30 0) '(30 4) '(30 6) '(30 10) '(30 11) '(30 12) '(30 14) '(30 15) '(30 16) '(30 17) '(30 18) '(30 19) '(30 20) '(30 22) '(31 0) '(31 1) '(31 4) '(31 5) '(31 6) '(31 12) '(31 13) '(31 14) '(31 18) '(31 20) '(31 21) '(31 22) '(31 23) '(31 24) '(31 25) '(31 26) '(32 1) '(32 4) '(32 6) '(32 13) '(32 18) '(32 26) '(33 1) '(33 2) '(33 3) '(33 4) '(33 6) '(33 13) '(33 16) '(33 17) '(33 18) '(33 20) '(33 21) '(33 22) '(33 24) '(33 25) '(33 26) '(34 6) '(34 7) '(34 8) '(34 9) '(34 11) '(34 12) '(34 13) '(34 16) '(34 18) '(34 19) '(34 20) '(34 22) '(34 24) '(34 26) '(35 9) '(35 10) '(35 11) '(35 13) '(35 14) '(35 15) '(35 16) '(35 17) '(35 18) '(35 20) '(35 21) '(35 22) '(35 24) '(35 25) '(35 26)))
(def coordinatesReset(list '(0 2) '(0 3) '(0 4) '(0 9) '(0 10) '(0 11) '(0 12) '(0 13) '(1 0) '(1 1) '(1 2) '(1 4) '(1 5) '(1 6) '(1 7) '(1 8) '(1 9) '(1 12) '(1 13) '(1 14) '(1 15) '(1 16) '(1 20) '(1 21) '(1 22) '(1 23) '(1 24) '(2 0) '(2 2) '(2 4) '(2 6) '(2 12) '(2 16) '(2 17) '(2 18) '(2 19) '(2 20) '(2 22) '(2 24) '(2 25) '(2 26) '(3 0) '(3 1) '(3 2) '(3 4) '(3 5) '(3 6) '(3 8) '(3 9) '(3 10) '(3 11) '(3 12) '(3 20) '(3 21) '(3 22) '(3 26) '(3 27) '(4 1) '(4 8) '(4 10) '(4 14) '(4 15) '(4 16) '(4 17) '(4 21) '(4 27) '(5 1) '(5 2) '(5 3) '(5 4) '(5 8) '(5 9) '(5 10) '(5 12) '(5 13) '(5 14) '(5 17) '(5 18) '(5 19) '(5 20) '(5 21) '(5 24) '(5 25) '(5 26) '(5 27) '(6 4) '(6 5) '(6 6) '(6 9) '(6 12) '(6 14) '(6 19) '(6 24) '(6 26) '(7 6) '(7 7) '(7 8) '(7 9) '(7 12) '(7 13) '(7 14) '(7 16) '(7 17) '(7 18) '(7 19) '(7 24) '(7 25) '(7 26) '(8 2) '(8 3) '(8 4) '(8 8) '(8 12) '(8 16) '(8 20) '(8 21) '(8 22) '(8 25) '(9 0) '(9 1) '(9 2) '(9 4) '(9 5) '(9 6) '(9 8) '(9 9) '(9 10) '(9 12) '(9 15) '(9 16) '(9 17) '(9 20) '(9 22) '(9 23) '(9 24) '(9 25) '(10 0) '(10 2) '(10 4) '(10 6) '(10 8) '(10 10) '(10 12) '(10 15) '(10 17) '(10 18) '(10 19) '(10 20) '(10 24) '(10 25) '(10 26) '(11 0) '(11 1) '(11 2) '(11 4) '(11 5) '(11 6) '(11 8) '(11 9) '(11 10) '(11 11) '(11 12) '(11 15) '(11 16) '(11 17) '(11 20) '(11 21) '(11 24) '(11 26) '(12 0) '(12 5) '(12 8) '(12 10) '(12 21) '(12 24) '(12 25) '(12 26) '(13 0) '(13 4) '(13 5) '(13 6) '(13 7) '(13 8) '(13 10) '(13 12) '(13 13) '(13 14) '(13 20) '(13 21) '(13 22) '(14 0) '(14 4) '(14 10) '(14 11) '(14 12) '(14 14) '(14 15) '(14 16) '(14 20) '(14 22) '(14 23) '(14 24) '(14 25) '(14 26) '(15 0) '(15 4) '(15 5) '(15 10) '(15 12) '(15 13) '(15 14) '(15 16) '(15 18) '(15 19) '(15 20) '(15 21) '(15 22) '(15 26) '(16 0) '(16 5) '(16 8) '(16 9) '(16 10) '(16 16) '(16 18) '(16 26) '(17 0) '(17 4) '(17 5) '(17 6) '(17 8) '(17 10) '(17 12) '(17 13) '(17 14) '(17 16) '(17 18) '(17 19) '(17 20) '(17 21) '(17 24) '(17 25) '(17 26) '(18 0) '(18 1) '(18 4) '(18 6) '(18 8) '(18 9) '(18 10) '(18 12) '(18 14) '(18 15) '(18 16) '(18 21) '(18 24) '(18 26) '(19 1) '(19 4) '(19 5) '(19 6) '(19 8) '(19 12) '(19 13) '(19 14) '(19 19) '(19 20) '(19 21) '(19 24) '(19 25) '(19 26) '(20 1) '(20 6) '(20 8) '(20 9) '(20 10) '(20 13) '(20 19) '(20 21) '(20 22) '(20 23) '(20 25) '(21 1) '(21 5) '(21 6) '(21 8) '(21 10) '(21 11) '(21 12) '(21 13) '(21 19) '(21 21) '(21 23) '(21 25) '(22 1) '(22 2) '(22 4) '(22 5) '(22 8) '(22 9) '(22 10) '(22 16) '(22 17) '(22 18) '(22 19) '(22 21) '(22 22) '(22 23) '(22 25) '(22 26) '(23 2) '(23 4) '(23 16) '(23 26) '(24 2) '(24 4) '(24 16) '(24 22) '(24 23) '(24 24) '(24 26) '(25 0) '(25 1) '(25 2) '(25 4) '(25 12) '(25 13) '(25 14) '(25 15) '(25 16) '(25 17) '(25 18) '(25 19) '(25 20) '(25 21) '(25 22) '(25 24) '(25 25) '(25 26) '(26 0) '(26 2) '(26 4) '(26 5) '(26 6) '(26 7) '(26 12) '(26 16) '(26 18) '(27 0) '(27 1) '(27 2) '(27 7) '(27 10) '(27 11) '(27 12) '(27 16) '(27 17) '(27 18) '(27 19) '(27 20) '(27 21) '(27 22) '(27 23) '(27 24) '(28 0) '(28 7) '(28 10) '(28 24) '(29 0) '(29 4) '(29 5) '(29 6) '(29 7) '(29 10) '(29 12) '(29 13) '(29 14) '(29 20) '(29 21) '(29 22) '(29 23) '(29 24) '(30 0) '(30 4) '(30 6) '(30 10) '(30 11) '(30 12) '(30 14) '(30 15) '(30 16) '(30 17) '(30 18) '(30 19) '(30 20) '(30 22) '(31 0) '(31 1) '(31 4) '(31 5) '(31 6) '(31 12) '(31 13) '(31 14) '(31 18) '(31 20) '(31 21) '(31 22) '(31 23) '(31 24) '(31 25) '(31 26) '(32 1) '(32 4) '(32 6) '(32 13) '(32 18) '(32 26) '(33 1) '(33 2) '(33 3) '(33 4) '(33 6) '(33 13) '(33 16) '(33 17) '(33 18) '(33 20) '(33 21) '(33 22) '(33 24) '(33 25) '(33 26) '(34 6) '(34 7) '(34 8) '(34 9) '(34 11) '(34 12) '(34 13) '(34 16) '(34 18) '(34 19) '(34 20) '(34 22) '(34 24) '(34 26) '(35 9) '(35 10) '(35 11) '(35 13) '(35 14) '(35 15) '(35 16) '(35 17) '(35 18) '(35 20) '(35 21) '(35 22) '(35 24) '(35 25) '(35 26)))
(def junctions(list ))
(def path(list ))
(def bestPath 372)

(defun append (x y)  
  (cond     
    ((null x) y)    
    ('t (cons (car x)               
      (append (cdr x) y)))))

(defun set-black (rloc)  
  (let* ((known (member rloc coordinates)))     
    ;dbg (logr (list "known = " known))     
    (if known       
      (let ((pre-list (cdr (member rloc (reverse coordinates)))))         
        (def coordinates           
          (append (reverse pre-list) (cdr known)))))))

(defun removeJunction (rloc)  
  (let* ((known (member rloc junctions)))     
    ;dbg (logr (list "known = " known))     
    (if known       
      (let ((pre-list (cdr (member rloc (reverse junctions)))))         
        (def junctions           
          (append (reverse pre-list) (cdr known)))))))

(defun destroyCell (rloc)  
  (let* ((known (member rloc coordinatesReset)))     
    ;dbg (logr (list "known = " known))     
    (if known       
      (let ((pre-list (cdr (member rloc (reverse coordinatesReset)))))         
        (def coordinatesReset          
          (append (reverse pre-list) (cdr known)))))))

(defun jp-move-bot ()
(let* ((botx (js "g_bot.x"))
         (boty (js "g_bot.y"))
		 )
         (def newx botx)
		 (def newy boty)
		 (def backup false)
		 (def junction false)
		 (def pDirections(list ))
		 (def direction -1)
		(let()
            (if(/= (member (list (+ botx 1) by) coordinates) nil) (def pDirections(cons 3 pDirections)))
			(if(/= (member (list botx (+ boty 1)) coordinates) nil) (def pDirections(cons 6 pDirections)))
		    (if(/= (member (list (- botx 1) boty) coordinates) nil) (def pDirections(cons 9 pDirections)))
			(if(/= (member (list botx (- boty 1)) coordinates) nil) (def pDirections(cons 0 pDirections)))
	    )
		(if (> (length pDirections) 0)
			(def direction (car(reverse pDirections)))
		)	
		
		(if (and(> (length pDirections) 1)(/= (member (list botx boty) junctions) nil))
			(let()
	      	    (def direction (car(cdr(reverse pDirections))))
				(removeJunction (list botx boty))
			)
			(if(> (length pDirections) 1)
			    (let()
			        (def junctions(cons (list botx boty) junctions))
				    (def junction true)
				)
			)
		)
		(cond
			((= direction 0)(def newy (- newy 1)))
			((= direction 3)(def newx (+ newx 1)))
			((= direction 6)(def newy (+ newy 1)))
			((= direction 9)(def newx (- newx 1)))
			((= direction -1)
			    (let()
					(logr (list "backing up to = " (caar path) (cadar path)))
				    (def newx (caar path))
				    (def newy (cadar path))
                    (def backup true)
					(set-black (list botx boty))
					(destroyCell (list botx boty))
				    (def path(cdr path))
				)
			)
		)		

(let* ((aaa (logr "Enter jp-move-bot"))
         (sz (js "g_grid.cell_size"))
         (zin (- sz 2))
         (botx (js "g_bot.x"))
         (boty (js "g_bot.y"))
         (xx (+ 1 (* sz botx)))
         (yy (+ 1 (* sz boty)))
         (pix (jp-pix-rbg-sum xx yy)))
	(js "stroke( 'green' )" ) ;; Named color.
        (if(= backup true) ;; "#RGB" color
		    (js "fill( 'black' )")
			(if(= junction true)
			    (js "fill( 'yellow' )")
				(js "fill( 'green' )")
			) 
		)
        (jp-rect xx yy zin zin))
	(if (/= backup true)
        (let ()
		    (set-black (list newx newy))
			(if(and (= botx 1)(= boty 1))(set-black (list 1 1)))
		    (def path(cons (list botx boty) path))
	    )
    )
	
	(if(and (= botx 35) (= boty 26)) ;Reset bot
	    (let()
		    (if(< (length path) bestPath)(def bestPath (length path)))
			(logr(list "Destination Reached! This path = " (length path) "Best path = " bestPath))
			(def coordinates coordinatesReset)
			(def path(list ))
			(def newx 1)
			(def newy 1)
			)								
    )
	(js (concat "g_bot.x = " (stgr newx)))
    (js (concat "g_bot.y = " (stgr newy)))
	(js (concat "sc.innerHTML = " (length path)))
	
))



;; ================================================== jp-get-tile-color ====
(defun jp-get-tile-color (rx ry)
  (let* ((sz (js "g_grid.cell_size"))
         (px (+ 2 (* sz rx)))
         (py (+ 2 (* sz ry))))
    (logr (list "get-tile-color rx,ry =" rx ry))
    (logr (list "sz,px,py =" sz px py))
    (jp-pix-rbg-sum px py)))

;; ================================================== jp-list-tile-cells ====
;; List all tile-cells.
(defun jp-list-tile-cells ()
  (let ((aaa (logr "Enter jp-list-tile-cells"))
        (xx 42)(iy 0)(leny 4)(ix 0)(lenx 2))
    (logr (list "list_fn called: xx =" xx))
    (setq cs-tiles nil)
    (logr (list "cs-tiles =" cs-tiles))
    (logr "Starting while ix.")
    (while (< ix lenx) ;; H shim >
      (logr (list "ix,lenx = " ix lenx ))
      (logr "Starting while iy.")
      (while (< iy leny) ;; H shim >
        (logr (list "iy,leny,xx = " iy leny xx ))
        (logr (list "x,y,clr = " ix iy
                    (jp-get-tile-color ix iy)))
        (setq iy (+ 1 iy))
        (setq xx (+ 1 xx)))
      (logr "Ending while iy.")
      (setq iy 0)
      (setq ix (+ 1 ix)))
    (logr "Ending while ix.")
    ))



;; ================================================== Setup l4j.draw_fn ====
;; Build & Setup l4j.draw_fn(): a JP lisp fn callable from JS.
;; NB, a JS global var isn't same as a JP global var.
;;  so we/JP must get hands on the JS var via a js() call.
;;  and we 
(let* ((l4j (js "g_l4job"))
       (fnx (lambda ( ) ;; Here's the JP lisp fn being built.
              (let ()
                  (jp-draw-bot) (jp-move-bot))
                ))
       (fny (lambda ( )
              (jp-list-tile-cells)))
       (fnz (lambda ( )
              (jp-zzdefg))))
  (set l4j "draw_fn" (export fnx)) ;; Here, we install the JP fn on a JS obj.
  (logr (list "g_l4job.draw_fn is set"))
  (logr (list "g_l4job.draw_fn() = " (js "g_l4job.draw_fn")))
  (set l4j "list_fn" (export fny))
  (logr (list "g_l4job.list_fn is set"))
  (set l4j "zzdefg_fn" (export fnz))
  (logr (list "g_l4job.zzdefg_fn is set"))
)

;; ==================================================
;; =================== New Maze Drawing Code ========
;; ==================================================

;; ================================================== jp-draw-maze-row-run ====
(defun jp-draw-maze-row-run ( rx-start ry rrow-run )
  ;; "At row ry, column rx, draw the row given the row-run list."
  (let* ((row-code (car rrow-run))
         (row-sprite-id (if (eq 'wall row-code) 0 1)) ;; Select cell sprite. Ugly.
         (runs (cdr rrow-run))
         (run-cnt nil)
         (cell-x rx-start))
    (logr (list "jp-draw-maze-row-run " rx-start ry rrow-run))
    (while runs
      (logr (list "drr runs " runs " row-sprite-id " row-sprite-id))
      (setq run-cnt (car runs))
      (setq runs (cdr runs)) ;; Adv.
      (while ( != 0 run-cnt )
        (logr (list "drr run-cnt " run-cnt))
        (if (= 1 row-sprite-id) ;; Ugly, draws only #1 cell type.
          (js (concat "draw_sprite_in_cell("
                      row-sprite-id "," cell-x "," ry ")"
                      )))
        (setq run-cnt (- run-cnt 1)) ;; Adv.
        (setq cell-x (+ 1 cell-x))) ;; Set for next cell.
      (setq row-sprite-id (- 1 row-sprite-id)) ;; Toggle for next row. Ugly.
      )))
        
;; ================================================== jp-draw-maze ====
(defun jp-draw-maze ( rrow-runs )
    ;; "Draw the maze cells given the row-runs structure."
  (let* ((rx-start 0) ;; Never changes.  Always start at left.
         (ry-start 0) ;; Row #.
         (row-run nil))
    (while rrow-runs
      (setq row-run (car rrow-runs))
      (setq rrow-runs (cdr rrow-runs)) ;; Adv.
      (logr (list "jp-draw-maze ry " ry-start ))
      (jp-draw-maze-row-run rx-start ry-start row-run)
      (setq ry-start (+ 1 ry-start)) ;; Set for next row.
      )))
    
;; ================================================== maze1-row-runs ====
;; Maze row-runs structure.
;;   Each row = (starting-cell-type . run-counts)
;;   Run-counts = 1st-cell-type-count, 2nd-cell-type-cnt, 1st-cell-type-cnt, etc.
(def maze1-row-runs ;; Maze for BestFS project #1.
'(
 (wall 1 3 5 10 6 7)
 (wall 1 1 1 3 3 1 1 1 6 5 2 1 1 1 3 3)
 (floor 4 1 1 2 4 10 6 5 1)
 (floor 1 4 1 2 1 24 1)
 (floor 4 1 2 1 4 1 3 1 3 2 5 2 5)
 (wall 1 1 1 1 2 1 2 1 1 3 1 3 1 1 1 2 3 1 2 1 1 1)
 (wall 1 3 2 2 1 3 1 1 3 5 4 1 2 6)
 (wall 1 1 5 1 5 1 12 4 4 1)
 (wall 1 1 1 3 1 7 2 7 11 1)
 (floor 2 1 1 1 3 1 1 1 1 4 1 1 1 1 1 1 1 11 2)
 (floor 1 2 3 3 10 1 3 4 4 4 1)
 (floor 1 2 1 7 1 2 1 6 1 5 1 2 1 3 2)
 (floor 4 1 7 1 3 1 3 1 1 3 3 1 3 2 1)
 (floor 2 3 1 1 1 5 1 1 1 1 1 1 3 3 1 3 1 1 5)
 (wall 1 1 2 4 5 3 1 3 5 1 3 3 3 1)
 (wall 1 1 2 1 4 3 2 1 3 1 6 1 4 1 4 1)
 (wall 1 2 1 1 2 3 1 1 2 5 3 6 2 1 2 3) ;;
 (wall 2 1 1 2 1 1 1 3 10 1 2 1 1 1 2 1 2 1 1 1)
 (wall 2 1 2 1 1 1 2 1 4 3 4 1 2 3 2 6)
 (wall 2 1 2 3 2 1 4 1 1 1 1 4 2 1 1 1 2 1 3 1)
 (wall 1 3 1 1 2 4 1 3 1 1 1 1 5 1 1 1 1 3 1 3)
 (wall 1 1 1 3 2 1 2 3 1 1 1 6 2 1 1 1 1 1 1 1 1 1 1 1)
 (wall 1 3 4 2 3 3 4 1 1 1 1 2 1 1 1 3 1 3)
 (wall 1 1 7 1 4 1 5 3 1 1 2 1 1 1 1 1)
 (wall 1 2 2 3 1 4 1 1 2 3 4 2 1 3 1 1 1 3)
 (wall 2 1 2 1 1 4 1 1 1 1 2 1 1 4 2 1 5 1 1 1 1 1)
 (wall 2 2 1 3 2 3 1 6 2 4 5 5)
 (wall 3 3)))

;; tests
;;(jp-draw-maze-row-run 0 0 '(wall 1 3 5 10 6 7))

;; ================================================== Call jp-draw-maze ====
(jp-draw-maze maze1-row-runs) ;; Draw the maze on the grid.

(logr "End html lisp draw fn ==========")

</script>


</html>
